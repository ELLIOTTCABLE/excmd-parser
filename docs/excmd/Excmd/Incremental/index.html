<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Incremental (excmd.Excmd.Incremental)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">excmd</a> &#x00BB; <a href="../index.html">Excmd</a> &#x00BB; Incremental</nav><h1>Module <code>Excmd.Incremental</code></h1></header><dl><dt class="spec type" id="type-checkpoint"><a href="#type-checkpoint" class="anchor"></a><code><span class="keyword">type </span>'a checkpoint</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><code>{</code><table class="record"><tr id="type-checkpoint.status" class="anchored"><td class="def field"><a href="#type-checkpoint.status" class="anchor"></a><code>status : <span class="type-var">'a</span> <a href="../../Excmd__ParserAutomaton/index.html#module-MenhirInterpreter">Excmd.ParserAutomaton.MenhirInterpreter</a>.checkpoint;</code></td></tr><tr id="type-checkpoint.buf" class="anchored"><td class="def field"><a href="#type-checkpoint.buf" class="anchor"></a><code>buf : <a href="../Lexer/index.html#type-buffer">Lexer.buffer</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">type </span>element</code><code><span class="keyword"> = </span><a href="../../Excmd__ParserAutomaton/index.html#module-MenhirInterpreter">Excmd.ParserAutomaton.MenhirInterpreter</a>.element</code></dt></dl><section><header><h2 id="incremental-entry-checkpoints"><a href="#incremental-entry-checkpoints" class="anchor"></a>Incremental entry-checkpoints</h2></header><dl><dt class="spec value" id="val-script"><a href="#val-script" class="anchor"></a><code><span class="keyword">val </span>script : <a href="../Lexer/index.html#type-buffer">Lexer.buffer</a> <span>&#45;&gt;</span> <a href="../AST/index.html#type-t">AST.t</a> <a href="index.html#type-checkpoint">checkpoint</a></code></dt><dd><p>Start the incremental Excmd parser with intent to consume, and produce, a single Excmd <a href="../Expression/index.html#type-t"><code>Expression.t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-script_of_string"><a href="#val-script_of_string" class="anchor"></a><code><span class="keyword">val </span>script_of_string : string <span>&#45;&gt;</span> <a href="../AST/index.html#type-t">AST.t</a> <a href="index.html#type-checkpoint">checkpoint</a></code></dt><dd><p>Helper to invoke <a href="index.html#val-expression"><code>expression</code></a> with a <code>string</code>.</p></dd></dl><dl><dt class="spec value" id="val-expression"><a href="#val-expression" class="anchor"></a><code><span class="keyword">val </span>expression : <a href="../Lexer/index.html#type-buffer">Lexer.buffer</a> <span>&#45;&gt;</span> <a href="../AST/index.html#type-expression">AST.expression</a> <a href="index.html#type-checkpoint">checkpoint</a></code></dt><dd><p>Start the incremental Excmd parser with intent to consume, and produce, a single Excmd <a href="../Expression/index.html#type-t"><code>Expression.t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-expression_of_string"><a href="#val-expression_of_string" class="anchor"></a><code><span class="keyword">val </span>expression_of_string : string <span>&#45;&gt;</span> <a href="../AST/index.html#type-expression">AST.expression</a> <a href="index.html#type-checkpoint">checkpoint</a></code></dt><dd><p>Helper to invoke <a href="index.html#val-expression"><code>expression</code></a> with a <code>string</code>.</p></dd></dl></section><section><header><h2 id="incremental-actions"><a href="#incremental-actions" class="anchor"></a>Incremental actions</h2></header><dl><dt class="spec value" id="val-continue"><a href="#val-continue" class="anchor"></a><code><span class="keyword">val </span>continue : accept:(<span class="type-var">'semantic</span> <span>&#45;&gt;</span> <span class="type-var">'result</span>) <span>&#45;&gt;</span> fail:(<span class="type-var">'semantic</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> <span class="type-var">'semantic</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> <span class="type-var">'result</span>) <span>&#45;&gt;</span> <span class="type-var">'semantic</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> <span class="type-var">'result</span></code></dt><dd><p>A helper for Menhir's incremental parsers. Feeds the given ... NYD</p></dd></dl></section><section><header><h2 id="high-level-introspection-helpers"><a href="#high-level-introspection-helpers" class="anchor"></a>High-level introspection helpers</h2><p>This set of functions are simply wrappers around Menhir's mechanics, to provide quick access to a few derived values. Although one can easily implement additional introspective tools in the same fashion, it's worth noting that any such helpers are going to be tightly coupled to the specifics of the grammar; and such, it's probably a good idea to keep them centrally located ... right here!</p><p>tl;dr upstream your usage, so I can excercise and standardize it, plz.</p></header><dl><dt class="spec value" id="val-acceptable_token"><a href="#val-acceptable_token" class="anchor"></a><code><span class="keyword">val </span>acceptable_token : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> <a href="../Tokens/index.html#type-token">Tokens.token</a></code></dt><dd><p><code>acceptable_token cp</code>, given a <code>cp</code> that is in an <code>InputNeeded</code> state, will return a single, arbitrarily chosen token that could be accepted by the parsing automaton.</p><p>JavaScript interface: <code>Checkpoint::acceptable_token</code>.</p></dd></dl><dl><dt class="spec value" id="val-acceptable_tokens"><a href="#val-acceptable_tokens" class="anchor"></a><code><span class="keyword">val </span>acceptable_tokens : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> <a href="../Tokens/index.html#type-token">Tokens.token</a> array</code></dt><dd><p><code>acceptable_tokens cp</code>, given a <code>cp</code> that is in an <code>InputNeeded</code> state, will return an array of example-tokens that <em>could</em> be accepted next by the parsing automaton.</p><p>JavaScript interface: <code>Checkpoint::acceptable_tokens</code>.</p></dd></dl><dl><dt class="spec value" id="val-current_command"><a href="#val-current_command" class="anchor"></a><code><span class="keyword">val </span>current_command : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>current_command cp</code> will, if the automaton has already accepted a IDENTIFIER token that will eventually become the <code>Expression.command</code> of the current expression, produce the name of that accepted command. If the parser is not in a state where a command-name has been accepted, then this will produce <code>None</code>.</p><p>JavaScript interface: <code>Checkpoint::command</code>.</p></dd></dl></section><section><header><h2 id="low-level-introspection"><a href="#low-level-introspection" class="anchor"></a>Low-level introspection</h2><p>The rest of these mostly exist to unwrap and name types for the use of the JavaScript interface; and are a pain to maintain. I really need automated generative tooling for variant-to-string converters ...</p></header><dl><dt class="spec value" id="val-automaton_status_str"><a href="#val-automaton_status_str" class="anchor"></a><code><span class="keyword">val </span>automaton_status_str : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>automaton_status_str cp</code> will return the current <a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec59">Menhir checkpoint-status</a> for the provided <code>cp</code>; this will be a string like <code>&quot;InputNeeded&quot;</code>, <code>&quot;Accepted&quot;</code>, and so on.</p><p>This is primarily for debugging, and generation of the appropriate JavaScript symbols for interop. You should, of course, do actual pattern-matching on the actual variant-type, if working from within OCaml.</p><p>JavaScript interface: <code>Checkpoint::automaton_status</code>.</p></dd></dl><dl><dt class="spec value" id="val-element_incoming_symbol_category_str"><a href="#val-element_incoming_symbol_category_str" class="anchor"></a><code><span class="keyword">val </span>element_incoming_symbol_category_str : <a href="index.html#type-element">element</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-incoming_symbol_category_str"><a href="#val-incoming_symbol_category_str" class="anchor"></a><code><span class="keyword">val </span>incoming_symbol_category_str : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>incoming_symbol_category_str cp</code> returns a string indicating whether the current symbol (the top of the automaton's stack) is a <code>&quot;terminal&quot;</code> or <code>&quot;nonterminal&quot;</code> symbol. If the stack is empty, this will produce <code>None</code>.</p><p>This will raise an exception if called on <code>Accepted</code> or <code>Rejected</code> checkpoints.</p><p>JavaScript interface: <code>Checkpoint::incoming_symbol_category</code>.</p></dd></dl><dl><dt class="spec value" id="val-element_incoming_symbol_type_str"><a href="#val-element_incoming_symbol_type_str" class="anchor"></a><code><span class="keyword">val </span>element_incoming_symbol_type_str : <a href="index.html#type-element">element</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-incoming_symbol_type_str"><a href="#val-incoming_symbol_type_str" class="anchor"></a><code><span class="keyword">val </span>incoming_symbol_type_str : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>incoming_symbol_type_str cp</code> returns a string describing the OCaml runtime type of the semantic values associated with the current symbol (that on top of the automaton's stack). If the stack is empty, this will produce <code>None</code>.</p><p>This will raise an exception if called on <code>Accepted</code> or <code>Rejected</code> checkpoints.</p><p>JavaScript interface: <code>Checkpoint::incoming_symbol_type</code>.</p></dd></dl><dl><dt class="spec value" id="val-element_incoming_symbol_str"><a href="#val-element_incoming_symbol_str" class="anchor"></a><code><span class="keyword">val </span>element_incoming_symbol_str : <a href="index.html#type-element">element</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-incoming_symbol_str"><a href="#val-incoming_symbol_str" class="anchor"></a><code><span class="keyword">val </span>incoming_symbol_str : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>incoming_symbol_str cp</code> returns a string describing the current symbol (that on top of the automaton's stack); e.g. <code>&quot;unterminated_expression&quot;</code> or <code>&quot;EQUALS&quot;</code>. If the stack is empty, this will produce <code>None</code>.</p><p>This will raise an exception if called on <code>Accepted</code> or <code>Rejected</code> checkpoints.</p><p>JavaScript interface: <code>Checkpoint::incoming_symbol</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_before"><a href="#val-get_before" class="anchor"></a><code><span class="keyword">val </span>get_before : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> option</code></dt><dt class="spec value" id="val-get_after"><a href="#val-get_after" class="anchor"></a><code><span class="keyword">val </span>get_after : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> option</code></dt><dt class="spec value" id="val-debug_checkpoint"><a href="#val-debug_checkpoint" class="anchor"></a><code><span class="keyword">val </span>debug_checkpoint : <span class="type-var">'a</span> <a href="index.html#type-checkpoint">checkpoint</a> <span>&#45;&gt;</span> unit</code></dt></dl></section></div></body></html>