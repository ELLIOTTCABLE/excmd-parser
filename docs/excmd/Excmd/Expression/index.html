<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Expression (excmd.Excmd.Expression)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">excmd</a> &#x00BB; <a href="../index.html">Excmd</a> &#x00BB; Expression</nav><h1>Module <code>Excmd.Expression</code></h1></header><aside><p>Most of these methods take their names from standard OCaml methods over maps. cf. <a href="https://reasonml.github.io/api/Map.Make.html"><code>Map.Make</code></a>.</p><p>(An important aspect of the behaviour of this API is the <a href="index.html#reso"><span>resolution of ambiguous words</span></a> in parsed commands. See more details at the bottom of this file.)</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p>An alias to <a href="../AST/index.html#type-expression"><code>AST.expression</code></a>, abstracted that mutation may be controlled.</p></dd></dl><dl><dt class="spec type" id="type-flag_payload"><a href="#type-flag_payload" class="anchor"></a><code><span class="keyword">type </span>flag_payload</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-flag_payload.Empty" class="anchored"><td class="def constructor"><a href="#type-flag_payload.Empty" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Empty</span></code></td></tr><tr id="type-flag_payload.Payload" class="anchored"><td class="def constructor"><a href="#type-flag_payload.Payload" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Payload</span><span class="keyword"> of </span>string <a href="../AST/index.html#type-or_subexpr">AST.or_subexpr</a></code></td></tr></table></dt></dl><section><header><h2 id="basic-getters"><a href="#basic-getters" class="anchor"></a>Basic getters</h2></header><aside><p>None of these may mutate the data-structure.</p></aside><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val </span>command : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../AST/index.html#type-or_subexpr">AST.or_subexpr</a></code></dt><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem fl expr</code> returns <code>true</code> if <code>expr</code> contains flag <code>fl</code>, <code>false</code> otherwise.</p><p>Notably, this <em>does not</em> <a href="index.html#reso"><span>resolve</span></a> any unresolved words from the parsed expression.</p></dd></dl><dl><dt class="spec value" id="val-is_resolved"><a href="#val-is_resolved" class="anchor"></a><code><span class="keyword">val </span>is_resolved : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_resolved fl expr</code> returns <code>true</code> if <code>expr</code> contains flag <code>fl</code> <em>and</em> flag <code>fl</code> is already <a href="index.html#reso"><span>resolved</span></a>; and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-has_payload"><a href="#val-has_payload" class="anchor"></a><code><span class="keyword">val </span>has_payload : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_payload fl expr</code> returns <code>true</code> if <code>expr</code> contains flag <code>fl</code>, flag <code>fl</code> is already <a href="index.html#reso"><span>resolved</span></a>, <em>and</em> flag <code>fl</code> resolved to a <code>string</code> payload instead of a <code>bool</code>. Returns <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-flags"><a href="#val-flags" class="anchor"></a><code><span class="keyword">val </span>flags : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string list</code></dt><dd><p><code>flags expr</code> returns a list of the flags used in <code>expr</code>, including only the <em>names</em> of flags - not the payloads.</p></dd></dl></section><section><header><h2 id="resolvers-(mutative-getters)"><a href="#resolvers-(mutative-getters)" class="anchor"></a>Resolvers (mutative getters)</h2></header><aside><p>All of these may, in some circumstances, mutate the data-structure.</p></aside><dl><dt class="spec value" id="val-positionals"><a href="#val-positionals" class="anchor"></a><code><span class="keyword">val </span>positionals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../AST/index.html#type-or_subexpr">AST.or_subexpr</a> list</code></dt><dd><p><code>positionals expr</code> returns a <code>list</code> of positional (non-flag) arguments in <code>expr</code>.</p><p>This <a href="index.html#reso"><span>fully resolves</span></a> <code>expr</code> — any ambiguous words will be consumed as positional arguments, becoming unavailable as flag-values.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (string <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f expr</code> applies <code>f</code> to all flags in expression <code>expr</code>. <code>f</code> receives the flag as its first argument, and the associated, fully-<a href="index.html#reso"><span>resolved</span></a> value as the second argument.</p><p>This <a href="index.html#reso"><span>fully resolves</span></a> <code>expr</code> — any ambiguous words will be consumed as the values to their associated flags, becoming unavailable as positional arguments.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : (int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-rev_iteri"><a href="#val-rev_iteri" class="anchor"></a><code><span class="keyword">val </span>rev_iteri : (int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-flag"><a href="#val-flag" class="anchor"></a><code><span class="keyword">val </span>flag : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> option</code></dt><dd><p><code>flag fl expr</code> finds the flag by the name of <code>fl</code>, <a href="index.html#reso"><span>resolves</span></a> it if necessary, and produces the payload there of, if any.</p><p>This can yield ...</p><ul><li><code>None</code>, indicating flag <code>fl</code> was not present at all.</li><li><code>Some Empty</code>, indicating flag <code>fl</code> was present, but resolved to having no payload.</li><li><code>Some (Payload str)</code>, indicating flag <code>fl</code> was present and became resolved to the payload <code>str</code>. This can involve resolution of the word immediately following <code>fl</code>.</li></ul></dd></dl></section><section><header><h2 id="other-helpers"><a href="#other-helpers" class="anchor"></a>Other helpers</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a <a href="index.html#type-t"><span>expression</span></a>. Implementation varies between platforms.</p></dd></dl><dl><dt class="spec value" id="val-hydrate"><a href="#val-hydrate" class="anchor"></a><code><span class="keyword">val </span>hydrate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../AST/index.html#type-expression">AST.expression</a></code></dt><dd><p>Type-converter between abstract <a href="index.html#type-t"><code>Expression.t</code></a> and concrete <a href="../AST/index.html#type-expression"><code>AST.expression</code></a>.</p><p>Careful; the operations in this module are intended to maintain safe invariants, consuming components of a <code>expression</code> in reasonable ways. You must not devolve one into a raw <a href="../AST/index.html"><code>AST</code></a> node, modify it unsafely, and then expect to continue to use the functions in this module.</p></dd></dl><dl><dt class="spec value" id="val-from_script"><a href="#val-from_script" class="anchor"></a><code><span class="keyword">val </span>from_script : <a href="../AST/index.html#type-t">AST.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> array</code></dt></dl></section><section><header><h2 id="reso"><a href="#reso" class="anchor"></a>Note: Resolution of ambiguous words</h2><p>It's important to note that a expression is a mutable structure, and that accesses intentionally mutate that structure — in particular, a given word in the original parsed string can only be <em>either</em> a positional argument <em>or</em> the argument to a preceding flag.</p><p>Any function that accesses either the <em>value</em> of a flag, or accesses the <a href="index.html#val-positionals"><code>positionals</code></a> at all, is going to “resolve” that word in the original source. If the word was ambiguously positioned, <em>that access will result in the datastructure changing</em> — to prevent the word later becoming resolved in an incompatible way.</p><p>For example: given the following input command as a <a href="index.html#type-t"><code>Expression.t</code></a>,</p><pre><code class="ml">hello --where world </code></pre><p>... there's two possible ways to interpret the <code>'world'</code>, chosen between by the order in which you invoke either <a href="index.html#val-positionals"><code>positionals</code></a>, or flag-value-reading functions (like <a href="index.html#val-iter"><code>iter</code></a> or <code>find</code>/<a href="index.html#val-flag"><code>flag</code></a>):</p><pre><code class="ml">(* FIXME: `flag` doesn't actually work this way ... *)
(* Yields zero positionals, and 'world' as the value associated with the flag '--where'. *)
let expr1 = Parser.expression_of_string &quot;hello --where world&quot; in
let where = Parser.flag &quot;where&quot; expr1 (* 'world' *) in
let xs = Parser.positionals expr1 (* [] *)

(* Yields one positional, 'world', and no value associated with the flag '--where'. *)
let expr2 = Parser.expression_of_string &quot;hello --where world&quot; in
let xs = Parser.positionals expr2 (* ['world'] *) in
let where = Parser.flag &quot;where&quot; expr2 (* None *)</code></pre><p>Once any ambiguous words have been so resolved (or when a function is called that inherently resolves <em>all</em> ambiguous words, such as <a href="index.html#val-positionals"><code>positionals</code></a> or <a href="index.html#val-iter"><code>iter</code></a>), a <a href="index.html#type-t"><code>Expression.t</code></a> is considered “fully resolved.” No functions in this module will further mutate such a <code>expression</code>.</p></header></section></div></body></html>