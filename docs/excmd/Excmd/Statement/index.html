<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Statement (excmd.Excmd.Statement)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">excmd</a> &#x00BB; <a href="../index.html">Excmd</a> &#x00BB; Statement</nav><h1>Module <code>Excmd.Statement</code></h1></header><aside><p>Most of these methods take their names from standard OCaml methods over maps. cf. <a href="https://reasonml.github.io/api/Map.Make.html"><code>Map.Make</code></a>.</p><p>(An important aspect of the behaviour of this API is the <a href="index.html#reso"><span>resolution of ambiguous words</span></a> in parsed commands. See more details at the bottom of this file.)</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p>An alias to <a href="../AST/index.html#type-statement"><code>AST.statement</code></a>, abstracted that mutation may be controlled.</p></dd></dl><dl><dt class="spec type" id="type-flag_payload"><a href="#type-flag_payload" class="anchor"></a><code><span class="keyword">type </span>flag_payload</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-flag_payload.Empty" class="anchored"><td class="def constructor"><a href="#type-flag_payload.Empty" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Empty</span></code></td></tr><tr id="type-flag_payload.Payload" class="anchored"><td class="def constructor"><a href="#type-flag_payload.Payload" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Payload</span><span class="keyword"> of </span>string</code></td></tr></table></dt></dl><section><header><h2 id="basic-getters"><a href="#basic-getters" class="anchor"></a>Basic getters</h2></header><aside><p>None of these may mutate the data-structure.</p></aside><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val </span>command : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem fl stmt</code> returns <code>true</code> if <code>stmt</code> contains flag <code>fl</code>, <code>false</code> otherwise.</p><p>Notably, this <em>does not</em> <a href="index.html#reso"><span>resolve</span></a> any unresolved words from the parsed statement.</p></dd></dl><dl><dt class="spec value" id="val-is_resolved"><a href="#val-is_resolved" class="anchor"></a><code><span class="keyword">val </span>is_resolved : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_resolved fl stmt</code> returns <code>true</code> if <code>stmt</code> contains flag <code>fl</code> <em>and</em> flag <code>fl</code> is already <a href="index.html#reso"><span>resolved</span></a>; and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-has_payload"><a href="#val-has_payload" class="anchor"></a><code><span class="keyword">val </span>has_payload : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_payload fl stmt</code> returns <code>true</code> if <code>stmt</code> contains flag <code>fl</code>, flag <code>fl</code> is already <a href="index.html#reso"><span>resolved</span></a>, <em>and</em> flag <code>fl</code> resolved to a <code>string</code> payload instead of a <code>bool</code>. Returns <code>false</code> otherwise.</p></dd></dl></section><section><header><h2 id="resolvers-(mutative-getters)"><a href="#resolvers-(mutative-getters)" class="anchor"></a>Resolvers (mutative getters)</h2></header><aside><p>All of these may, in some circumstances, mutate the data-structure.</p></aside><dl><dt class="spec value" id="val-positionals"><a href="#val-positionals" class="anchor"></a><code><span class="keyword">val </span>positionals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string array</code></dt><dd><p><code>positionals stmt</code> returns a <code>array</code> of positional (non-flag) arguments in <code>stmt</code>.</p><p>This <a href="index.html#reso"><span>fully resolves</span></a> <code>stmt</code> — any ambiguous words will be consumed as positional arguments, becoming unavailable as flag-values.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (string <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f stmt</code> applies <code>f</code> to all flags in statement <code>stmt</code>. <code>f</code> receives the flag as its first argument, and the associated, fully-<a href="index.html#reso"><span>resolved</span></a> value as the second argument.</p><p>This <a href="index.html#reso"><span>fully resolves</span></a> <code>stmt</code> — any ambiguous words will be consumed as the values to their associated flags, becoming unavailable as positional arguments.</p></dd></dl><dl><dt class="spec value" id="val-flag"><a href="#val-flag" class="anchor"></a><code><span class="keyword">val </span>flag : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> option</code></dt><dd><p><code>flag fl stmt</code> finds the flag by the name of <code>fl</code>, <a href="index.html#reso"><span>resolves</span></a> it if necessary, and produces the payload there of, if any.</p><p>This can yield ...</p><ul><li><code>None</code>, indicating flag <code>fl</code> was not present at all.</li><li><code>Some Empty</code>, indicating flag <code>fl</code> was present, but resolved to having no payload.</li><li><code>Some
    (Payload str)</code>, indicating flag <code>fl</code> was present and became resolved to the payload <code>str</code>. This can involve resolution of the word immediately following <code>fl</code>.</li></ul></dd></dl></section><section><header><h2 id="other-helpers"><a href="#other-helpers" class="anchor"></a>Other helpers</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a <a href="index.html#type-t"><span>statement</span></a>. Implementation varies between platforms.</p></dd></dl><dl><dt class="spec value" id="val-hydrate"><a href="#val-hydrate" class="anchor"></a><code><span class="keyword">val </span>hydrate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../AST/index.html#type-statement">AST.statement</a></code></dt><dd><p>Type-converter between abstract <a href="index.html#type-t"><code>Statement.t</code></a> and concrete <a href="../AST/index.html#type-statement"><code>AST.statement</code></a>.</p><p>Careful; the operations in this module are intended to maintain safe invariants, consuming components of a <code>statement</code> in reasonable ways. You must not devolve one into a raw <a href="../AST/index.html"><code>AST</code></a> node, modify it unsafely, and then expect to continue to use the functions in this module.</p></dd></dl><dl><dt class="spec value" id="val-from_script"><a href="#val-from_script" class="anchor"></a><code><span class="keyword">val </span>from_script : <a href="../AST/index.html#type-t">AST.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> array</code></dt><dt class="spec value" id="val-payload_to_opt"><a href="#val-payload_to_opt" class="anchor"></a><code><span class="keyword">val </span>payload_to_opt : <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> string option</code></dt><dd><p>Helper to convert a <code>flag_payload</code> to a BuckleScript-friendly <code>option</code>.</p></dd></dl></section><section><header><h2 id="reso"><a href="#reso" class="anchor"></a>Note: Resolution of ambiguous words</h2><p>It's important to note that a statement is a mutable structure, and that accesses intentionally mutate that structure — in particular, a given word in the original parsed string can only be <em>either</em> a positional argument <em>or</em> the argument to a preceding flag.</p><p>Any function that accesses either the <em>value</em> of a flag, or accesses the <a href="index.html#val-positionals"><code>positionals</code></a> at all, is going to “resolve” that word in the original source. If the word was ambiguously positioned, <em>that access will result in the datastructure changing</em> — to prevent the word later becoming resolved in an incompatible way.</p><p>For example: given the following input command as a <a href="index.html#type-t"><code>Statement.t</code></a>,</p><pre><code class="ml">hello --where world </code></pre><p>... there's two possible ways to interpret the <code>'world'</code>, chosen between by the order in which you invoke either <a href="index.html#val-positionals"><code>positionals</code></a>, or flag-value-reading functions (like <a href="index.html#val-iter"><code>iter</code></a> or <code>find</code>/<a href="index.html#val-flag"><code>flag</code></a>):</p><pre><code class="ml">(* FIXME: `flag` doesn't actually work this way ... *) (* Yields zero positionals,
                                                                and 'world' as the value associated with the flag '--where'. *) let stmt1 =
                                                                      Parser.statement_of_string &quot;hello --where world&quot; in let where = Parser.flag &quot;where&quot;
                                                                                                                                stmt1 (* 'world' *) let xs = Parser.positionals stmt1 (* [] *)

      (* Yields one positional, 'world', and no value associated with the flag '--where'.
      *) let stmt2 = Parser.statement_of_string &quot;hello --where world&quot; in let xs =
                                                                            Parser.positionals stmt2 (* ['world'] *) let where = Parser.flag &quot;where&quot; stmt2 (*
   None *) </code></pre><p>Once any ambiguous words have been so resolved (or when a function is called that inherently resolves <em>all</em> ambiguous words, such as <a href="index.html#val-positionals"><code>positionals</code></a> or <a href="index.html#val-iter"><code>iter</code></a>), a <a href="index.html#type-t"><code>Statement.t</code></a> is considered “fully resolved.” No functions in this module will further mutate such a <code>statement</code>.</p></header></section></div></body></html>