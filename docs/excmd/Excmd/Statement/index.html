<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Statement (excmd.Excmd.Statement)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">excmd</a> &#x00BB; <a href="../index.html">Excmd</a> &#x00BB; Statement</nav><h1>Module <code>Excmd.Statement</code></h1></header><aside><p>Most of these methods take their names from standard OCaml methods over maps. cf. <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><code>Map</code>.Make</span></p></aside><section><header><h2 id="reso"><a href="#reso" class="anchor"></a>Resolution of ambiguous words</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p>An alias to <a href="../AST/index.html#type-statement"><code>AST.statement</code></a>, abstracted that mutation may be controlled.</p></dd></dl><dl><dt class="spec type" id="type-flag_payload"><a href="#type-flag_payload" class="anchor"></a><code><span class="keyword">type </span>flag_payload</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-flag_payload.Empty" class="anchored"><td class="def constructor"><a href="#type-flag_payload.Empty" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Empty</span></code></td></tr><tr id="type-flag_payload.Payload" class="anchored"><td class="def constructor"><a href="#type-flag_payload.Payload" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Payload</span><span class="keyword"> of </span>string</code></td></tr></table></dt></dl></section><section><header><h2 id="basic-getters"><a href="#basic-getters" class="anchor"></a>Basic getters</h2></header><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val </span>command : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem fl stmt</code> returns <code>true</code> if <code>stmt</code> contains flag <code>fl</code>, <code>false</code> otherwise. * * Notably, this <em>does not</em> <a href="index.html#reso"><span>resolve</span></a> any unresolved words from the parsed statement.</p></dd></dl><dl><dt class="spec value" id="val-is_resolved"><a href="#val-is_resolved" class="anchor"></a><code><span class="keyword">val </span>is_resolved : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_resolved fl stmt</code> returns <code>true</code> if <code>stmt</code> contains flag <code>fl</code> <em>and</em> flag <code>fl</code> is already * <a href="index.html#reso"><span>resolved</span></a>; and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-has_payload"><a href="#val-has_payload" class="anchor"></a><code><span class="keyword">val </span>has_payload : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_payload fl stmt</code> returns <code>true</code> if <code>stmt</code> contains flag <code>fl</code>, flag <code>fl</code> is already * <a href="index.html#reso"><span>resolved</span></a>, <em>and</em> flag <code>fl</code> resolved to a <code>string</code> payload instead of a <code>bool</code>. * Returns <code>false</code> otherwise.</p></dd></dl></section><section><header><h2 id="resolvers-(mutative-getters)"><a href="#resolvers-(mutative-getters)" class="anchor"></a>Resolvers (mutative getters)</h2></header><dl><dt class="spec value" id="val-positionals"><a href="#val-positionals" class="anchor"></a><code><span class="keyword">val </span>positionals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string array</code></dt><dd><p><code>positionals stmt</code> returns a <code>array</code> of positional (non-flag) arguments in <code>stmt</code>. * * This <a href="index.html#reso"><span>fully resolves</span></a> <code>stmt</code> — any ambiguous words will be consumed as positional * arguments, becoming unavailable as flag-values.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (string <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f stmt</code> applies <code>f</code> to all flags in statement <code>stmt</code>. <code>f</code> receives the flag as its first * argument, and the associated, fully-<a href="index.html#reso"><span>resolved</span></a> value as the second argument. * * This <a href="index.html#reso"><span>fully resolves</span></a> <code>stmt</code> — any ambiguous words will be consumed as the values to * their associated flags, becoming unavailable as positional arguments.</p></dd></dl><dl><dt class="spec value" id="val-flag"><a href="#val-flag" class="anchor"></a><code><span class="keyword">val </span>flag : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-flag_payload">flag_payload</a> option</code></dt><dt class="spec value" id="val-payload_to_opt"><a href="#val-payload_to_opt" class="anchor"></a><code><span class="keyword">val </span>payload_to_opt : <a href="index.html#type-flag_payload">flag_payload</a> <span>&#45;&gt;</span> string option</code></dt><dd><p>Helper to convert a <code>flag_payload</code> to a BuckleScript-friendly <code>option</code>.</p></dd></dl></section><section><header><h2 id="other-helpers"><a href="#other-helpers" class="anchor"></a>Other helpers</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a <a href="index.html#type-t"><span>statement</span></a>. Implementation varies between platforms.</p></dd></dl><dl><dt class="spec value" id="val-hydrate"><a href="#val-hydrate" class="anchor"></a><code><span class="keyword">val </span>hydrate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../AST/index.html#type-statement">AST.statement</a></code></dt><dd><p>Type-converter between abstract <a href="index.html#type-t"><code>Statement.t</code></a> and concrete <a href="../AST/index.html#type-statement"><code>AST.statement</code></a>. * * Careful; the operations in this module are intended to maintain safe invariants, consuming * components of a <code>statement</code> in reasonable ways. You must not devolve one into a raw <a href="../AST/index.html"><code>AST</code></a> node, * modify it unsafely, and then expect to continue to use the functions in this module.</p></dd></dl><dl><dt class="spec value" id="val-from_script"><a href="#val-from_script" class="anchor"></a><code><span class="keyword">val </span>from_script : <a href="../AST/index.html#type-t">AST.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> array</code></dt></dl></section></div></body></html>