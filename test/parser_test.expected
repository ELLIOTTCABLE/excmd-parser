

### Simple, single command:
Parser.expression "test"
{ "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single command, with count:
Parser.expression "2test"
{ "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single command, with single positional parameter:
Parser.expression "test foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single command, with single positional URL:
Parser.expression "test google.com/search"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "google.com/search" ] ] ]
}

### Single command, count, and single positional parameter:
Parser.expression "2test foo"
{
  "count": 2,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single command, with multiple positional parameters:
Parser.expression "test foo bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Positional", [ "Literal", "foo" ] ]
  ]
}

### Single command, count, and multiple positional parameters:
Parser.expression "2test foo bar"
{
  "count": 2,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Positional", [ "Literal", "foo" ] ]
  ]
}

### Single command, with single boolean flag:
Parser.expression "test --foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ] ]
}

### Single command, with multiple boolean flags:
Parser.expression "test --foo --bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "bar", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ]
  ]
}

### Single command, with single boolean short-flag:
Parser.expression "test -f"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "f", "payload": [ "Absent" ] } ] ]
}

### Single command, with multiple, concatenated boolean short-flags:
Parser.expression "test -foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "f", "payload": [ "Absent" ] } ]
  ]
}

### Single command, with multiple, separated boolean short-flags:
Parser.expression "test -f -o -o"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "o", "payload": [ "Absent" ] } ],
    [ "Flag", { "name": "f", "payload": [ "Absent" ] } ]
  ]
}

### Single command, with single possibly-parameterized flag:
Parser.expression "test --foo bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command, with single possibly-parameterized short-flag:
Parser.expression "test -f bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "f", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command, single possibly-parameterized short-flag, and a URL:
Parser.expression "test -f google.com/search"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "google.com/search" ] ],
    [ "Flag", { "name": "f", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command with single possibly-parameterized flag followed by a positional parameter:
Parser.expression "test --foo bar baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command with two possibly-parameterized flags:
Parser.expression "test --foo bar --baz widget"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "widget" ] ],
    [ "Flag", { "name": "baz", "payload": [ "Unresolved" ] } ],
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single command, with single explicitly-parameterized flag:
Parser.expression "test --foo=bar"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [
      "Flag",
      { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
    ]
  ]
}

### Single command with single explicitly-parameterized flag followed by a positional parameter:
Parser.expression "test --foo=bar baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [
      "Flag",
      { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
    ]
  ]
}

### Single command, single explicitly-parameterized flag with a URL payload, followed by a positional parameter:
Parser.expression "test --foo=google.com/search baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [
      "Flag",
      {
        "name": "foo",
        "payload": [ "Resolved", [ "Literal", "google.com/search" ] ]
      }
    ]
  ]
}

### Single command with a bare-double-dash:
Parser.expression "test --"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "--" ] ] ]
}

### Single command with a bare-double-dash followed by a long-flag:
Parser.expression "test -- --foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ],
    [ "Positional", [ "Literal", "--" ] ]
  ]
}

### Single command with a bare-double-dash followed by another, normal positional:
Parser.expression "test -- foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "foo" ] ],
    [ "Positional", [ "Literal", "--" ] ]
  ]
}

### Single command with mixed flags and parameters:
Parser.expression "test --foo bar --baz=widget qux -qu ux"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "ux" ] ],
    [ "Flag", { "name": "u", "payload": [ "Unresolved" ] } ],
    [ "Flag", { "name": "q", "payload": [ "Absent" ] } ],
    [ "Positional", [ "Literal", "qux" ] ],
    [
      "Flag",
      { "name": "baz", "payload": [ "Resolved", [ "Literal", "widget" ] ] }
    ],
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single dquoted command:
Parser.expression "\"test\""
{ "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] }

### Single dquoted command with bare positional:
Parser.expression "\"test\" foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single dquoted command with bare flag:
Parser.expression "\"test\" --foo"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ] ]
}

### Bare command with single dquoted positional:
Parser.expression "test \"foo\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single dquoted command with single dquoted positional:
Parser.expression "\"test\" \"foo\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Positional", [ "Literal", "foo" ] ] ]
}

### Single dquoted command, bare flag, and dquoted payload:
Parser.expression "\"test\" --foo \"bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
  ]
}

### Single dquoted command, flag-esque positional, and positional:
Parser.expression "\"test\" \"--foo\" \"bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "bar" ] ],
    [ "Positional", [ "Literal", "--foo" ] ]
  ]
}

### Bare command, bare-double-dash, and quoted positional:
Parser.expression "test -- \"foo bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "foo bar" ] ],
    [ "Positional", [ "Literal", "--" ] ]
  ]
}

### Bare command, long-flag, flag's name quoted:
Parser.expression "test --\"foo\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo", "payload": [ "Absent" ] } ] ]
}

### Bare command, long-flag, with a space in the flag's name:
Parser.expression "test --\"foo bar\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [ [ "Flag", { "name": "foo bar", "payload": [ "Absent" ] } ] ]
}

### Bare command, long-flag w/ space in name, possibly-parameterized:
Parser.expression "test --\"foo bar\" baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [ "Positional", [ "Literal", "baz" ] ],
    [ "Flag", { "name": "foo bar", "payload": [ "Unresolved" ] } ]
  ]
}

### Bare command, long-flag w/ space in name, explicitly-parameterized:
Parser.expression "test --\"foo bar\"=baz"
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [
      "Flag",
      { "name": "foo bar", "payload": [ "Resolved", [ "Literal", "baz" ] ] }
    ]
  ]
}

### Bare command, long-flag w/ space in name, explicit, quoted parameter:
Parser.expression "test --\"foo bar\"=\"baz widget\""
{
  "count": 1,
  "cmd": [ "Literal", "test" ],
  "rev_args": [
    [
      "Flag",
      {
        "name": "foo bar",
        "payload": [ "Resolved", [ "Literal", "baz widget" ] ]
      }
    ]
  ]
}

### Expressions separated by semicolons:
Parser.script "test; 2test; 3test"
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### Expressions separated by semicolons, with a trailing semicolon:
Parser.script "test; 2test; 3test;"
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### Expressions, with arguments, separated by semicolons:
Parser.script "test --foo bar; 2test --foo=bar; 3test --foo bar"
{
  "expressions": [
    {
      "count": 1,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    },
    {
      "count": 2,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [
          "Flag",
          { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
        ]
      ]
    },
    {
      "count": 3,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    }
  ]
}

### Expressions, with arguments, separated by semicolons, with a trailing semicolon:
Parser.script "test --foo bar; 2test --foo=bar; 3test --foo bar;"
{
  "expressions": [
    {
      "count": 1,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    },
    {
      "count": 2,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [
          "Flag",
          { "name": "foo", "payload": [ "Resolved", [ "Literal", "bar" ] ] }
        ]
      ]
    },
    {
      "count": 3,
      "cmd": [ "Literal", "test" ],
      "rev_args": [
        [ "Positional", [ "Literal", "bar" ] ],
        [ "Flag", { "name": "foo", "payload": [ "Unresolved" ] } ]
      ]
    }
  ]
}

### Newlines after expressions:
Parser.script "test;\n   2test;\n   3test"
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### Newlines after expressions, with a trailing newline:
Parser.script "test;\n   2test;\n   3test;\n   "
{
  "expressions": [
    { "count": 1, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 2, "cmd": [ "Literal", "test" ], "rev_args": [] },
    { "count": 3, "cmd": [ "Literal", "test" ], "rev_args": [] }
  ]
}

### An acceptable expression, incrementally:
Incremental.expression "hello --where=world"
{
  "count": 1,
  "cmd": [ "Literal", "hello" ],
  "rev_args": [
    [
      "Flag",
      { "name": "where", "payload": [ "Resolved", [ "Literal", "world" ] ] }
    ]
  ]
}

### A failing expression, incrementally:
Incremental.expression "hello --where="
fail-continuation invoked! cool.


### Listing of acceptable tokens during a failure:
Incremental.expression "hello --where="
URL_START, QUOTE_OPEN, IDENTIFIER, BARE_DOUBLE_DASH


### Dumping of stack-debugging information from a checkpoint:
Incremental.expression "hello --where="
InputNeeded
Terminal
unit
EQUALS
EQUALS : (unit) Terminal
_flag_long : (string) Nonterminal
command : (string) Nonterminal
option_COUNT_ : (string option) Nonterminal
list_COLON_ : (unit list) Nonterminal


### Ascertaining of current command from a checkpoint:
Incremental.expression "a_command_name --blah="
a_command_name
